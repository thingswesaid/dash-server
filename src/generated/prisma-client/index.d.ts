// Code generated by Prisma (prisma@1.22.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  order: (where?: OrderWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  promoCode: (where?: PromoCodeWhereInput) => Promise<boolean>;
  promoVideo: (where?: PromoVideoWhereInput) => Promise<boolean>;
  sitePromo: (where?: SitePromoWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Order>;
  ordersConnection: (
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OrderConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  promoCode: (where: PromoCodeWhereUniqueInput) => PromoCodePromise;
  promoCodes: (
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PromoCode>;
  promoCodesConnection: (
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PromoCodeConnectionPromise;
  promoVideo: (where: PromoVideoWhereUniqueInput) => PromoVideoPromise;
  promoVideos: (
    args?: {
      where?: PromoVideoWhereInput;
      orderBy?: PromoVideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PromoVideo>;
  promoVideosConnection: (
    args?: {
      where?: PromoVideoWhereInput;
      orderBy?: PromoVideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PromoVideoConnectionPromise;
  sitePromo: (where: SitePromoWhereUniqueInput) => SitePromoPromise;
  sitePromoes: (
    args?: {
      where?: SitePromoWhereInput;
      orderBy?: SitePromoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SitePromo>;
  sitePromoesConnection: (
    args?: {
      where?: SitePromoWhereInput;
      orderBy?: SitePromoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SitePromoConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Video>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (
    args: { data: OrderUpdateInput; where: OrderWhereUniqueInput }
  ) => OrderPromise;
  updateManyOrders: (
    args: { data: OrderUpdateManyMutationInput; where?: OrderWhereInput }
  ) => BatchPayloadPromise;
  upsertOrder: (
    args: {
      where: OrderWhereUniqueInput;
      create: OrderCreateInput;
      update: OrderUpdateInput;
    }
  ) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createPromoCode: (data: PromoCodeCreateInput) => PromoCodePromise;
  updatePromoCode: (
    args: { data: PromoCodeUpdateInput; where: PromoCodeWhereUniqueInput }
  ) => PromoCodePromise;
  updateManyPromoCodes: (
    args: {
      data: PromoCodeUpdateManyMutationInput;
      where?: PromoCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPromoCode: (
    args: {
      where: PromoCodeWhereUniqueInput;
      create: PromoCodeCreateInput;
      update: PromoCodeUpdateInput;
    }
  ) => PromoCodePromise;
  deletePromoCode: (where: PromoCodeWhereUniqueInput) => PromoCodePromise;
  deleteManyPromoCodes: (where?: PromoCodeWhereInput) => BatchPayloadPromise;
  createPromoVideo: (data: PromoVideoCreateInput) => PromoVideoPromise;
  updatePromoVideo: (
    args: { data: PromoVideoUpdateInput; where: PromoVideoWhereUniqueInput }
  ) => PromoVideoPromise;
  updateManyPromoVideos: (
    args: {
      data: PromoVideoUpdateManyMutationInput;
      where?: PromoVideoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPromoVideo: (
    args: {
      where: PromoVideoWhereUniqueInput;
      create: PromoVideoCreateInput;
      update: PromoVideoUpdateInput;
    }
  ) => PromoVideoPromise;
  deletePromoVideo: (where: PromoVideoWhereUniqueInput) => PromoVideoPromise;
  deleteManyPromoVideos: (where?: PromoVideoWhereInput) => BatchPayloadPromise;
  createSitePromo: (data: SitePromoCreateInput) => SitePromoPromise;
  updateSitePromo: (
    args: { data: SitePromoUpdateInput; where: SitePromoWhereUniqueInput }
  ) => SitePromoPromise;
  updateManySitePromoes: (
    args: {
      data: SitePromoUpdateManyMutationInput;
      where?: SitePromoWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSitePromo: (
    args: {
      where: SitePromoWhereUniqueInput;
      create: SitePromoCreateInput;
      update: SitePromoUpdateInput;
    }
  ) => SitePromoPromise;
  deleteSitePromo: (where: SitePromoWhereUniqueInput) => SitePromoPromise;
  deleteManySitePromoes: (where?: SitePromoWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => VideoPromise;
  updateManyVideos: (
    args: { data: VideoUpdateManyMutationInput; where?: VideoWhereInput }
  ) => BatchPayloadPromise;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  promoCode: (
    where?: PromoCodeSubscriptionWhereInput
  ) => PromoCodeSubscriptionPayloadSubscription;
  promoVideo: (
    where?: PromoVideoSubscriptionWhereInput
  ) => PromoVideoSubscriptionPayloadSubscription;
  sitePromo: (
    where?: SitePromoSubscriptionWhereInput
  ) => SitePromoSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type VideoType = "ZODIAC" | "PICKACARD";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "title_ASC"
  | "title_DESC"
  | "link_ASC"
  | "link_DESC"
  | "preview_ASC"
  | "preview_DESC"
  | "image_ASC"
  | "image_DESC"
  | "placeholder_ASC"
  | "placeholder_DESC"
  | "published_ASC"
  | "published_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "start_ASC"
  | "start_DESC"
  | "type_ASC"
  | "type_DESC"
  | "familyId_ASC"
  | "familyId_DESC"
  | "suggest_ASC"
  | "suggest_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "subscribed_ASC"
  | "subscribed_DESC"
  | "active_ASC"
  | "active_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "paymentId_ASC"
  | "paymentId_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "link_ASC"
  | "link_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "placeholder_ASC"
  | "placeholder_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PromoCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "valid_ASC"
  | "valid_DESC"
  | "type_ASC"
  | "type_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PromoVideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "link_ASC"
  | "link_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "placeholder_ASC"
  | "placeholder_DESC"
  | "familyId_ASC"
  | "familyId_DESC"
  | "banner_ASC"
  | "banner_DESC"
  | "bannerMobile_ASC"
  | "bannerMobile_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PromoOffer = "BUY1GET1" | "BUY2GET1";

export type SitePromoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "promoOffer_ASC"
  | "promoOffer_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  paymentId?: String;
}>;

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  preview?: String;
  preview_not?: String;
  preview_in?: String[] | String;
  preview_not_in?: String[] | String;
  preview_lt?: String;
  preview_lte?: String;
  preview_gt?: String;
  preview_gte?: String;
  preview_contains?: String;
  preview_not_contains?: String;
  preview_starts_with?: String;
  preview_not_starts_with?: String;
  preview_ends_with?: String;
  preview_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  placeholder?: String;
  placeholder_not?: String;
  placeholder_in?: String[] | String;
  placeholder_not_in?: String[] | String;
  placeholder_lt?: String;
  placeholder_lte?: String;
  placeholder_gt?: String;
  placeholder_gte?: String;
  placeholder_contains?: String;
  placeholder_not_contains?: String;
  placeholder_starts_with?: String;
  placeholder_not_starts_with?: String;
  placeholder_ends_with?: String;
  placeholder_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  published?: Boolean;
  published_not?: Boolean;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  start?: Int;
  start_not?: Int;
  start_in?: Int[] | Int;
  start_not_in?: Int[] | Int;
  start_lt?: Int;
  start_lte?: Int;
  start_gt?: Int;
  start_gte?: Int;
  type?: VideoType;
  type_not?: VideoType;
  type_in?: VideoType[] | VideoType;
  type_not_in?: VideoType[] | VideoType;
  familyId?: String;
  familyId_not?: String;
  familyId_in?: String[] | String;
  familyId_not_in?: String[] | String;
  familyId_lt?: String;
  familyId_lte?: String;
  familyId_gt?: String;
  familyId_gte?: String;
  familyId_contains?: String;
  familyId_not_contains?: String;
  familyId_starts_with?: String;
  familyId_not_starts_with?: String;
  familyId_ends_with?: String;
  familyId_not_ends_with?: String;
  promoVideo?: PromoVideoWhereInput;
  suggest?: Boolean;
  suggest_not?: Boolean;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  subscribed?: Boolean;
  subscribed_not?: Boolean;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  active?: Boolean;
  active_not?: Boolean;
  orders_every?: OrderWhereInput;
  orders_some?: OrderWhereInput;
  orders_none?: OrderWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  paymentId?: String;
  paymentId_not?: String;
  paymentId_in?: String[] | String;
  paymentId_not_in?: String[] | String;
  paymentId_lt?: String;
  paymentId_lte?: String;
  paymentId_gt?: String;
  paymentId_gte?: String;
  paymentId_contains?: String;
  paymentId_not_contains?: String;
  paymentId_starts_with?: String;
  paymentId_not_starts_with?: String;
  paymentId_ends_with?: String;
  paymentId_not_ends_with?: String;
  user?: UserWhereInput;
  video?: VideoWhereInput;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export interface PromoVideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  placeholder?: String;
  placeholder_not?: String;
  placeholder_in?: String[] | String;
  placeholder_not_in?: String[] | String;
  placeholder_lt?: String;
  placeholder_lte?: String;
  placeholder_gt?: String;
  placeholder_gte?: String;
  placeholder_contains?: String;
  placeholder_not_contains?: String;
  placeholder_starts_with?: String;
  placeholder_not_starts_with?: String;
  placeholder_ends_with?: String;
  placeholder_not_ends_with?: String;
  familyId?: String;
  familyId_not?: String;
  familyId_in?: String[] | String;
  familyId_not_in?: String[] | String;
  familyId_lt?: String;
  familyId_lte?: String;
  familyId_gt?: String;
  familyId_gte?: String;
  familyId_contains?: String;
  familyId_not_contains?: String;
  familyId_starts_with?: String;
  familyId_not_starts_with?: String;
  familyId_ends_with?: String;
  familyId_not_ends_with?: String;
  banner?: String;
  banner_not?: String;
  banner_in?: String[] | String;
  banner_not_in?: String[] | String;
  banner_lt?: String;
  banner_lte?: String;
  banner_gt?: String;
  banner_gte?: String;
  banner_contains?: String;
  banner_not_contains?: String;
  banner_starts_with?: String;
  banner_not_starts_with?: String;
  banner_ends_with?: String;
  banner_not_ends_with?: String;
  bannerMobile?: String;
  bannerMobile_not?: String;
  bannerMobile_in?: String[] | String;
  bannerMobile_not_in?: String[] | String;
  bannerMobile_lt?: String;
  bannerMobile_lte?: String;
  bannerMobile_gt?: String;
  bannerMobile_gte?: String;
  bannerMobile_contains?: String;
  bannerMobile_not_contains?: String;
  bannerMobile_starts_with?: String;
  bannerMobile_not_starts_with?: String;
  bannerMobile_ends_with?: String;
  bannerMobile_not_ends_with?: String;
  type?: VideoType;
  type_not?: VideoType;
  type_in?: VideoType[] | VideoType;
  type_not_in?: VideoType[] | VideoType;
  video?: VideoWhereInput;
  AND?: PromoVideoWhereInput[] | PromoVideoWhereInput;
  OR?: PromoVideoWhereInput[] | PromoVideoWhereInput;
  NOT?: PromoVideoWhereInput[] | PromoVideoWhereInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  placeholder?: String;
  placeholder_not?: String;
  placeholder_in?: String[] | String;
  placeholder_not_in?: String[] | String;
  placeholder_lt?: String;
  placeholder_lte?: String;
  placeholder_gt?: String;
  placeholder_gte?: String;
  placeholder_contains?: String;
  placeholder_not_contains?: String;
  placeholder_starts_with?: String;
  placeholder_not_starts_with?: String;
  placeholder_ends_with?: String;
  placeholder_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export type PromoCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface PromoCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  valid?: Boolean;
  valid_not?: Boolean;
  type?: VideoType;
  type_not?: VideoType;
  type_in?: VideoType[] | VideoType;
  type_not_in?: VideoType[] | VideoType;
  endDate?: String;
  endDate_not?: String;
  endDate_in?: String[] | String;
  endDate_not_in?: String[] | String;
  endDate_lt?: String;
  endDate_lte?: String;
  endDate_gt?: String;
  endDate_gte?: String;
  endDate_contains?: String;
  endDate_not_contains?: String;
  endDate_starts_with?: String;
  endDate_not_starts_with?: String;
  endDate_ends_with?: String;
  endDate_not_ends_with?: String;
  user?: UserWhereInput;
  video?: VideoWhereInput;
  AND?: PromoCodeWhereInput[] | PromoCodeWhereInput;
  OR?: PromoCodeWhereInput[] | PromoCodeWhereInput;
  NOT?: PromoCodeWhereInput[] | PromoCodeWhereInput;
}

export type PromoVideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SitePromoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SitePromoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: VideoType;
  type_not?: VideoType;
  type_in?: VideoType[] | VideoType;
  type_not_in?: VideoType[] | VideoType;
  promoOffer?: PromoOffer;
  promoOffer_not?: PromoOffer;
  promoOffer_in?: PromoOffer[] | PromoOffer;
  promoOffer_not_in?: PromoOffer[] | PromoOffer;
  startDate?: String;
  startDate_not?: String;
  startDate_in?: String[] | String;
  startDate_not_in?: String[] | String;
  startDate_lt?: String;
  startDate_lte?: String;
  startDate_gt?: String;
  startDate_gte?: String;
  startDate_contains?: String;
  startDate_not_contains?: String;
  startDate_starts_with?: String;
  startDate_not_starts_with?: String;
  startDate_ends_with?: String;
  startDate_not_ends_with?: String;
  endDate?: String;
  endDate_not?: String;
  endDate_in?: String[] | String;
  endDate_not_in?: String[] | String;
  endDate_lt?: String;
  endDate_lte?: String;
  endDate_gt?: String;
  endDate_gte?: String;
  endDate_contains?: String;
  endDate_not_contains?: String;
  endDate_starts_with?: String;
  endDate_not_starts_with?: String;
  endDate_ends_with?: String;
  endDate_not_ends_with?: String;
  AND?: SitePromoWhereInput[] | SitePromoWhereInput;
  OR?: SitePromoWhereInput[] | SitePromoWhereInput;
  NOT?: SitePromoWhereInput[] | SitePromoWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OrderCreateInput {
  paymentId: String;
  user?: UserCreateOneWithoutOrdersInput;
  video?: VideoCreateOneInput;
}

export interface UserCreateOneWithoutOrdersInput {
  create?: UserCreateWithoutOrdersInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutOrdersInput {
  firstName?: String;
  lastName?: String;
  email: String;
  phone?: String;
  ips?: UserCreateipsInput;
  subscribed?: Boolean;
  videos?: VideoCreateManyWithoutUsersInput;
  active?: Boolean;
}

export interface UserCreateipsInput {
  set?: String[] | String;
}

export interface VideoCreateManyWithoutUsersInput {
  create?: VideoCreateWithoutUsersInput[] | VideoCreateWithoutUsersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutUsersInput {
  name: String;
  title?: String;
  link: String;
  preview: String;
  image: String;
  placeholder?: String;
  published?: Boolean;
  amount?: Float;
  start: Int;
  type: VideoType;
  familyId?: String;
  promoVideo?: PromoVideoCreateOneWithoutVideoInput;
  suggest?: Boolean;
}

export interface PromoVideoCreateOneWithoutVideoInput {
  create?: PromoVideoCreateWithoutVideoInput;
  connect?: PromoVideoWhereUniqueInput;
}

export interface PromoVideoCreateWithoutVideoInput {
  link: String;
  title: String;
  description: String;
  image: String;
  placeholder?: String;
  familyId?: String;
  banner: String;
  bannerMobile: String;
  type: VideoType;
}

export interface VideoCreateOneInput {
  create?: VideoCreateInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoCreateInput {
  name: String;
  title?: String;
  link: String;
  preview: String;
  image: String;
  placeholder?: String;
  users?: UserCreateManyWithoutVideosInput;
  published?: Boolean;
  amount?: Float;
  start: Int;
  type: VideoType;
  familyId?: String;
  promoVideo?: PromoVideoCreateOneWithoutVideoInput;
  suggest?: Boolean;
}

export interface UserCreateManyWithoutVideosInput {
  create?: UserCreateWithoutVideosInput[] | UserCreateWithoutVideosInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutVideosInput {
  firstName?: String;
  lastName?: String;
  email: String;
  phone?: String;
  ips?: UserCreateipsInput;
  subscribed?: Boolean;
  active?: Boolean;
  orders?: OrderCreateManyWithoutUserInput;
}

export interface OrderCreateManyWithoutUserInput {
  create?: OrderCreateWithoutUserInput[] | OrderCreateWithoutUserInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutUserInput {
  paymentId: String;
  video?: VideoCreateOneInput;
}

export interface OrderUpdateInput {
  paymentId?: String;
  user?: UserUpdateOneWithoutOrdersInput;
  video?: VideoUpdateOneInput;
}

export interface UserUpdateOneWithoutOrdersInput {
  create?: UserCreateWithoutOrdersInput;
  update?: UserUpdateWithoutOrdersDataInput;
  upsert?: UserUpsertWithoutOrdersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutOrdersDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  videos?: VideoUpdateManyWithoutUsersInput;
  active?: Boolean;
}

export interface UserUpdateipsInput {
  set?: String[] | String;
}

export interface VideoUpdateManyWithoutUsersInput {
  create?: VideoCreateWithoutUsersInput[] | VideoCreateWithoutUsersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutUsersInput[]
    | VideoUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutUsersInput[]
    | VideoUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutUsersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutUsersDataInput;
}

export interface VideoUpdateWithoutUsersDataInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  promoVideo?: PromoVideoUpdateOneWithoutVideoInput;
  suggest?: Boolean;
}

export interface PromoVideoUpdateOneWithoutVideoInput {
  create?: PromoVideoCreateWithoutVideoInput;
  update?: PromoVideoUpdateWithoutVideoDataInput;
  upsert?: PromoVideoUpsertWithoutVideoInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PromoVideoWhereUniqueInput;
}

export interface PromoVideoUpdateWithoutVideoDataInput {
  link?: String;
  title?: String;
  description?: String;
  image?: String;
  placeholder?: String;
  familyId?: String;
  banner?: String;
  bannerMobile?: String;
  type?: VideoType;
}

export interface PromoVideoUpsertWithoutVideoInput {
  update: PromoVideoUpdateWithoutVideoDataInput;
  create: PromoVideoCreateWithoutVideoInput;
}

export interface VideoUpsertWithWhereUniqueWithoutUsersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutUsersDataInput;
  create: VideoCreateWithoutUsersInput;
}

export interface VideoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  preview?: String;
  preview_not?: String;
  preview_in?: String[] | String;
  preview_not_in?: String[] | String;
  preview_lt?: String;
  preview_lte?: String;
  preview_gt?: String;
  preview_gte?: String;
  preview_contains?: String;
  preview_not_contains?: String;
  preview_starts_with?: String;
  preview_not_starts_with?: String;
  preview_ends_with?: String;
  preview_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  placeholder?: String;
  placeholder_not?: String;
  placeholder_in?: String[] | String;
  placeholder_not_in?: String[] | String;
  placeholder_lt?: String;
  placeholder_lte?: String;
  placeholder_gt?: String;
  placeholder_gte?: String;
  placeholder_contains?: String;
  placeholder_not_contains?: String;
  placeholder_starts_with?: String;
  placeholder_not_starts_with?: String;
  placeholder_ends_with?: String;
  placeholder_not_ends_with?: String;
  published?: Boolean;
  published_not?: Boolean;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  start?: Int;
  start_not?: Int;
  start_in?: Int[] | Int;
  start_not_in?: Int[] | Int;
  start_lt?: Int;
  start_lte?: Int;
  start_gt?: Int;
  start_gte?: Int;
  type?: VideoType;
  type_not?: VideoType;
  type_in?: VideoType[] | VideoType;
  type_not_in?: VideoType[] | VideoType;
  familyId?: String;
  familyId_not?: String;
  familyId_in?: String[] | String;
  familyId_not_in?: String[] | String;
  familyId_lt?: String;
  familyId_lte?: String;
  familyId_gt?: String;
  familyId_gte?: String;
  familyId_contains?: String;
  familyId_not_contains?: String;
  familyId_starts_with?: String;
  familyId_not_starts_with?: String;
  familyId_ends_with?: String;
  familyId_not_ends_with?: String;
  suggest?: Boolean;
  suggest_not?: Boolean;
  AND?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  OR?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  NOT?: VideoScalarWhereInput[] | VideoScalarWhereInput;
}

export interface VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput;
  data: VideoUpdateManyDataInput;
}

export interface VideoUpdateManyDataInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  suggest?: Boolean;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export interface VideoUpdateOneInput {
  create?: VideoCreateInput;
  update?: VideoUpdateDataInput;
  upsert?: VideoUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface VideoUpdateDataInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  users?: UserUpdateManyWithoutVideosInput;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  promoVideo?: PromoVideoUpdateOneWithoutVideoInput;
  suggest?: Boolean;
}

export interface UserUpdateManyWithoutVideosInput {
  create?: UserCreateWithoutVideosInput[] | UserCreateWithoutVideosInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutVideosInput[]
    | UserUpdateWithWhereUniqueWithoutVideosInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutVideosInput[]
    | UserUpsertWithWhereUniqueWithoutVideosInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutVideosInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutVideosDataInput;
}

export interface UserUpdateWithoutVideosDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  active?: Boolean;
  orders?: OrderUpdateManyWithoutUserInput;
}

export interface OrderUpdateManyWithoutUserInput {
  create?: OrderCreateWithoutUserInput[] | OrderCreateWithoutUserInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutUserInput[]
    | OrderUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutUserInput[]
    | OrderUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutUserDataInput;
}

export interface OrderUpdateWithoutUserDataInput {
  paymentId?: String;
  video?: VideoUpdateOneInput;
}

export interface OrderUpsertWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutUserDataInput;
  create: OrderCreateWithoutUserInput;
}

export interface OrderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  paymentId?: String;
  paymentId_not?: String;
  paymentId_in?: String[] | String;
  paymentId_not_in?: String[] | String;
  paymentId_lt?: String;
  paymentId_lte?: String;
  paymentId_gt?: String;
  paymentId_gte?: String;
  paymentId_contains?: String;
  paymentId_not_contains?: String;
  paymentId_starts_with?: String;
  paymentId_not_starts_with?: String;
  paymentId_ends_with?: String;
  paymentId_not_ends_with?: String;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  paymentId?: String;
}

export interface UserUpsertWithWhereUniqueWithoutVideosInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutVideosDataInput;
  create: UserCreateWithoutVideosInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  subscribed?: Boolean;
  subscribed_not?: Boolean;
  active?: Boolean;
  active_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  active?: Boolean;
}

export interface VideoUpsertNestedInput {
  update: VideoUpdateDataInput;
  create: VideoCreateInput;
}

export interface OrderUpdateManyMutationInput {
  paymentId?: String;
}

export interface ProductCreateInput {
  link: String;
  name: String;
  description: String;
  image: String;
  placeholder: String;
  type: String;
}

export interface ProductUpdateInput {
  link?: String;
  name?: String;
  description?: String;
  image?: String;
  placeholder?: String;
  type?: String;
}

export interface ProductUpdateManyMutationInput {
  link?: String;
  name?: String;
  description?: String;
  image?: String;
  placeholder?: String;
  type?: String;
}

export interface PromoCodeCreateInput {
  code: String;
  valid?: Boolean;
  type: VideoType;
  endDate?: String;
  user: UserCreateOneInput;
  video?: VideoCreateOneInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  firstName?: String;
  lastName?: String;
  email: String;
  phone?: String;
  ips?: UserCreateipsInput;
  subscribed?: Boolean;
  videos?: VideoCreateManyWithoutUsersInput;
  active?: Boolean;
  orders?: OrderCreateManyWithoutUserInput;
}

export interface PromoCodeUpdateInput {
  code?: String;
  valid?: Boolean;
  type?: VideoType;
  endDate?: String;
  user?: UserUpdateOneRequiredInput;
  video?: VideoUpdateOneInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  videos?: VideoUpdateManyWithoutUsersInput;
  active?: Boolean;
  orders?: OrderUpdateManyWithoutUserInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PromoCodeUpdateManyMutationInput {
  code?: String;
  valid?: Boolean;
  type?: VideoType;
  endDate?: String;
}

export interface PromoVideoCreateInput {
  link: String;
  title: String;
  description: String;
  image: String;
  placeholder?: String;
  familyId?: String;
  banner: String;
  bannerMobile: String;
  type: VideoType;
  video?: VideoCreateOneWithoutPromoVideoInput;
}

export interface VideoCreateOneWithoutPromoVideoInput {
  create?: VideoCreateWithoutPromoVideoInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoCreateWithoutPromoVideoInput {
  name: String;
  title?: String;
  link: String;
  preview: String;
  image: String;
  placeholder?: String;
  users?: UserCreateManyWithoutVideosInput;
  published?: Boolean;
  amount?: Float;
  start: Int;
  type: VideoType;
  familyId?: String;
  suggest?: Boolean;
}

export interface PromoVideoUpdateInput {
  link?: String;
  title?: String;
  description?: String;
  image?: String;
  placeholder?: String;
  familyId?: String;
  banner?: String;
  bannerMobile?: String;
  type?: VideoType;
  video?: VideoUpdateOneWithoutPromoVideoInput;
}

export interface VideoUpdateOneWithoutPromoVideoInput {
  create?: VideoCreateWithoutPromoVideoInput;
  update?: VideoUpdateWithoutPromoVideoDataInput;
  upsert?: VideoUpsertWithoutPromoVideoInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface VideoUpdateWithoutPromoVideoDataInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  users?: UserUpdateManyWithoutVideosInput;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  suggest?: Boolean;
}

export interface VideoUpsertWithoutPromoVideoInput {
  update: VideoUpdateWithoutPromoVideoDataInput;
  create: VideoCreateWithoutPromoVideoInput;
}

export interface PromoVideoUpdateManyMutationInput {
  link?: String;
  title?: String;
  description?: String;
  image?: String;
  placeholder?: String;
  familyId?: String;
  banner?: String;
  bannerMobile?: String;
  type?: VideoType;
}

export interface SitePromoCreateInput {
  type: VideoType;
  promoOffer: PromoOffer;
  startDate?: String;
  endDate?: String;
}

export interface SitePromoUpdateInput {
  type?: VideoType;
  promoOffer?: PromoOffer;
  startDate?: String;
  endDate?: String;
}

export interface SitePromoUpdateManyMutationInput {
  type?: VideoType;
  promoOffer?: PromoOffer;
  startDate?: String;
  endDate?: String;
}

export interface UserUpdateInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  videos?: VideoUpdateManyWithoutUsersInput;
  active?: Boolean;
  orders?: OrderUpdateManyWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  phone?: String;
  ips?: UserUpdateipsInput;
  subscribed?: Boolean;
  active?: Boolean;
}

export interface VideoUpdateInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  users?: UserUpdateManyWithoutVideosInput;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  promoVideo?: PromoVideoUpdateOneWithoutVideoInput;
  suggest?: Boolean;
}

export interface VideoUpdateManyMutationInput {
  name?: String;
  title?: String;
  link?: String;
  preview?: String;
  image?: String;
  placeholder?: String;
  published?: Boolean;
  amount?: Float;
  start?: Int;
  type?: VideoType;
  familyId?: String;
  suggest?: Boolean;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface PromoCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PromoCodeWhereInput;
  AND?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
  OR?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
  NOT?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
}

export interface PromoVideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PromoVideoWhereInput;
  AND?: PromoVideoSubscriptionWhereInput[] | PromoVideoSubscriptionWhereInput;
  OR?: PromoVideoSubscriptionWhereInput[] | PromoVideoSubscriptionWhereInput;
  NOT?: PromoVideoSubscriptionWhereInput[] | PromoVideoSubscriptionWhereInput;
}

export interface SitePromoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SitePromoWhereInput;
  AND?: SitePromoSubscriptionWhereInput[] | SitePromoSubscriptionWhereInput;
  OR?: SitePromoSubscriptionWhereInput[] | SitePromoSubscriptionWhereInput;
  NOT?: SitePromoSubscriptionWhereInput[] | SitePromoSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  paymentId: String;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  paymentId: () => Promise<String>;
  user: <T = UserPromise>() => T;
  video: <T = VideoPromise>() => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  paymentId: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  video: <T = VideoSubscription>() => T;
}

export interface User {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email: String;
  phone?: String;
  ips: String[];
  subscribed: Boolean;
  active: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  ips: () => Promise<String[]>;
  subscribed: () => Promise<Boolean>;
  videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  active: () => Promise<Boolean>;
  orders: <T = FragmentableArray<Order>>(
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  ips: () => Promise<AsyncIterator<String[]>>;
  subscribed: () => Promise<AsyncIterator<Boolean>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  active: () => Promise<AsyncIterator<Boolean>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(
    args?: {
      where?: OrderWhereInput;
      orderBy?: OrderOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Video {
  id: ID_Output;
  name: String;
  title?: String;
  link: String;
  preview: String;
  image: String;
  placeholder?: String;
  published: Boolean;
  amount?: Float;
  start: Int;
  type: VideoType;
  familyId?: String;
  suggest: Boolean;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  link: () => Promise<String>;
  preview: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  published: () => Promise<Boolean>;
  amount: () => Promise<Float>;
  start: () => Promise<Int>;
  type: () => Promise<VideoType>;
  familyId: () => Promise<String>;
  promoVideo: <T = PromoVideoPromise>() => T;
  suggest: () => Promise<Boolean>;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  preview: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  published: () => Promise<AsyncIterator<Boolean>>;
  amount: () => Promise<AsyncIterator<Float>>;
  start: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  familyId: () => Promise<AsyncIterator<String>>;
  promoVideo: <T = PromoVideoSubscription>() => T;
  suggest: () => Promise<AsyncIterator<Boolean>>;
}

export interface PromoVideo {
  id: ID_Output;
  link: String;
  title: String;
  description: String;
  image: String;
  placeholder?: String;
  familyId: String;
  banner: String;
  bannerMobile: String;
  type: VideoType;
}

export interface PromoVideoPromise extends Promise<PromoVideo>, Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  familyId: () => Promise<String>;
  banner: () => Promise<String>;
  bannerMobile: () => Promise<String>;
  type: () => Promise<VideoType>;
  video: <T = VideoPromise>() => T;
}

export interface PromoVideoSubscription
  extends Promise<AsyncIterator<PromoVideo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  familyId: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  bannerMobile: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  video: <T = VideoSubscription>() => T;
}

export interface OrderConnection {}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderEdge {
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  link: String;
  name: String;
  description: String;
  image: String;
  placeholder: String;
  type: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  type: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface ProductConnection {}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PromoCode {
  id: ID_Output;
  code: String;
  valid: Boolean;
  type: VideoType;
  endDate?: String;
}

export interface PromoCodePromise extends Promise<PromoCode>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  valid: () => Promise<Boolean>;
  type: () => Promise<VideoType>;
  endDate: () => Promise<String>;
  user: <T = UserPromise>() => T;
  video: <T = VideoPromise>() => T;
}

export interface PromoCodeSubscription
  extends Promise<AsyncIterator<PromoCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  valid: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  endDate: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  video: <T = VideoSubscription>() => T;
}

export interface PromoCodeConnection {}

export interface PromoCodeConnectionPromise
  extends Promise<PromoCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PromoCodeEdge>>() => T;
  aggregate: <T = AggregatePromoCodePromise>() => T;
}

export interface PromoCodeConnectionSubscription
  extends Promise<AsyncIterator<PromoCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PromoCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePromoCodeSubscription>() => T;
}

export interface PromoCodeEdge {
  cursor: String;
}

export interface PromoCodeEdgePromise
  extends Promise<PromoCodeEdge>,
    Fragmentable {
  node: <T = PromoCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PromoCodeEdgeSubscription
  extends Promise<AsyncIterator<PromoCodeEdge>>,
    Fragmentable {
  node: <T = PromoCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePromoCode {
  count: Int;
}

export interface AggregatePromoCodePromise
  extends Promise<AggregatePromoCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePromoCodeSubscription
  extends Promise<AsyncIterator<AggregatePromoCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PromoVideoConnection {}

export interface PromoVideoConnectionPromise
  extends Promise<PromoVideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PromoVideoEdge>>() => T;
  aggregate: <T = AggregatePromoVideoPromise>() => T;
}

export interface PromoVideoConnectionSubscription
  extends Promise<AsyncIterator<PromoVideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PromoVideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePromoVideoSubscription>() => T;
}

export interface PromoVideoEdge {
  cursor: String;
}

export interface PromoVideoEdgePromise
  extends Promise<PromoVideoEdge>,
    Fragmentable {
  node: <T = PromoVideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PromoVideoEdgeSubscription
  extends Promise<AsyncIterator<PromoVideoEdge>>,
    Fragmentable {
  node: <T = PromoVideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePromoVideo {
  count: Int;
}

export interface AggregatePromoVideoPromise
  extends Promise<AggregatePromoVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePromoVideoSubscription
  extends Promise<AsyncIterator<AggregatePromoVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SitePromo {
  id: ID_Output;
  type: VideoType;
  promoOffer: PromoOffer;
  startDate?: String;
  endDate?: String;
}

export interface SitePromoPromise extends Promise<SitePromo>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VideoType>;
  promoOffer: () => Promise<PromoOffer>;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
}

export interface SitePromoSubscription
  extends Promise<AsyncIterator<SitePromo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  promoOffer: () => Promise<AsyncIterator<PromoOffer>>;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
}

export interface SitePromoConnection {}

export interface SitePromoConnectionPromise
  extends Promise<SitePromoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SitePromoEdge>>() => T;
  aggregate: <T = AggregateSitePromoPromise>() => T;
}

export interface SitePromoConnectionSubscription
  extends Promise<AsyncIterator<SitePromoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SitePromoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSitePromoSubscription>() => T;
}

export interface SitePromoEdge {
  cursor: String;
}

export interface SitePromoEdgePromise
  extends Promise<SitePromoEdge>,
    Fragmentable {
  node: <T = SitePromoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SitePromoEdgeSubscription
  extends Promise<AsyncIterator<SitePromoEdge>>,
    Fragmentable {
  node: <T = SitePromoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSitePromo {
  count: Int;
}

export interface AggregateSitePromoPromise
  extends Promise<AggregateSitePromo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSitePromoSubscription
  extends Promise<AsyncIterator<AggregateSitePromo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoConnection {}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface VideoEdge {
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  paymentId: String;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  paymentId: () => Promise<String>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  paymentId: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  link: String;
  name: String;
  description: String;
  image: String;
  placeholder: String;
  type: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  type: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface PromoCodeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PromoCodeSubscriptionPayloadPromise
  extends Promise<PromoCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PromoCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PromoCodePreviousValuesPromise>() => T;
}

export interface PromoCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PromoCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PromoCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PromoCodePreviousValuesSubscription>() => T;
}

export interface PromoCodePreviousValues {
  id: ID_Output;
  code: String;
  valid: Boolean;
  type: VideoType;
  endDate?: String;
}

export interface PromoCodePreviousValuesPromise
  extends Promise<PromoCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  valid: () => Promise<Boolean>;
  type: () => Promise<VideoType>;
  endDate: () => Promise<String>;
}

export interface PromoCodePreviousValuesSubscription
  extends Promise<AsyncIterator<PromoCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  valid: () => Promise<AsyncIterator<Boolean>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  endDate: () => Promise<AsyncIterator<String>>;
}

export interface PromoVideoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PromoVideoSubscriptionPayloadPromise
  extends Promise<PromoVideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PromoVideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PromoVideoPreviousValuesPromise>() => T;
}

export interface PromoVideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PromoVideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PromoVideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PromoVideoPreviousValuesSubscription>() => T;
}

export interface PromoVideoPreviousValues {
  id: ID_Output;
  link: String;
  title: String;
  description: String;
  image: String;
  placeholder?: String;
  familyId: String;
  banner: String;
  bannerMobile: String;
  type: VideoType;
}

export interface PromoVideoPreviousValuesPromise
  extends Promise<PromoVideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  link: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  familyId: () => Promise<String>;
  banner: () => Promise<String>;
  bannerMobile: () => Promise<String>;
  type: () => Promise<VideoType>;
}

export interface PromoVideoPreviousValuesSubscription
  extends Promise<AsyncIterator<PromoVideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  link: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  familyId: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  bannerMobile: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<VideoType>>;
}

export interface SitePromoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SitePromoSubscriptionPayloadPromise
  extends Promise<SitePromoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SitePromoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SitePromoPreviousValuesPromise>() => T;
}

export interface SitePromoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SitePromoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SitePromoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SitePromoPreviousValuesSubscription>() => T;
}

export interface SitePromoPreviousValues {
  id: ID_Output;
  type: VideoType;
  promoOffer: PromoOffer;
  startDate?: String;
  endDate?: String;
}

export interface SitePromoPreviousValuesPromise
  extends Promise<SitePromoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VideoType>;
  promoOffer: () => Promise<PromoOffer>;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
}

export interface SitePromoPreviousValuesSubscription
  extends Promise<AsyncIterator<SitePromoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  promoOffer: () => Promise<AsyncIterator<PromoOffer>>;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName?: String;
  lastName?: String;
  email: String;
  phone?: String;
  ips: String[];
  subscribed: Boolean;
  active: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  ips: () => Promise<String[]>;
  subscribed: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  ips: () => Promise<AsyncIterator<String[]>>;
  subscribed: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface VideoPreviousValues {
  id: ID_Output;
  name: String;
  title?: String;
  link: String;
  preview: String;
  image: String;
  placeholder?: String;
  published: Boolean;
  amount?: Float;
  start: Int;
  type: VideoType;
  familyId?: String;
  suggest: Boolean;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  title: () => Promise<String>;
  link: () => Promise<String>;
  preview: () => Promise<String>;
  image: () => Promise<String>;
  placeholder: () => Promise<String>;
  published: () => Promise<Boolean>;
  amount: () => Promise<Float>;
  start: () => Promise<Int>;
  type: () => Promise<VideoType>;
  familyId: () => Promise<String>;
  suggest: () => Promise<Boolean>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  preview: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  placeholder: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  amount: () => Promise<AsyncIterator<Float>>;
  start: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<VideoType>>;
  familyId: () => Promise<AsyncIterator<String>>;
  suggest: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "PromoCode",
    embedded: false
  },
  {
    name: "PromoOffer",
    embedded: false
  },
  {
    name: "PromoVideo",
    embedded: false
  },
  {
    name: "SitePromo",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "VideoType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
